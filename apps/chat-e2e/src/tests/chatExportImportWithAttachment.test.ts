import dialTest from '@/src/core/dialFixtures';
import {
  API,
  Attachment,
  ExpectedMessages,
  Import,
  MenuOptions,
  ModelIds,
  TestConversation,
} from '@/src/testData';
import { UploadDownloadData } from '@/src/ui/pages';
import { BucketUtil, FileUtil } from '@/src/utils';
import { expect } from '@playwright/test';

let dalleImageUrl: string;
let gptProVisionImageUrl: string;
let gptProVisionAttachmentPath: string;
let dalleAttachmentPath: string;

dialTest(
  'Export and import file with pictures generated by DALL-E-3.\n' +
    'Export and import file with pictures loaded to Gemini Pro Vision.\n' +
    'Cancel the Export with attachments.\n' +
    'Export with attachments after the export cancellation.\n' +
    'Stop the import.\n' +
    'Import chat with attachments after the import stop',
  async ({
    conversationData,
    fileApiHelper,
    dataInjector,
    localStorageManager,
    dialHomePage,
    conversations,
    conversationDropdownMenu,
    chatBar,
    confirmationDialog,
    chatMessages,
    importExportLoader,
    setTestIds,
  }) => {
    setTestIds(
      'EPMRTC-1975',
      'EPMRTC-1976',
      'EPMRTC-1980',
      'EPMRTC-1981',
      'EPMRTC-1982',
      'EPMRTC-1984',
    );
    let dalleConversation: TestConversation;
    let gptProVisionConversation: TestConversation;
    let historyConversation: TestConversation;
    let exportedData: UploadDownloadData;
    let conversationPath: string;

    await dialTest.step(
      'Upload images to DALL-E-3 path and root folder and prepare conversations with request and response containing this images',
      async () => {
        dalleImageUrl = await fileApiHelper.putFile(
          Attachment.sunImageName,
          API.modelFilePath(ModelIds.DALLE),
        );
        gptProVisionImageUrl = await fileApiHelper.putFile(
          Attachment.heartImageName,
        );

        dalleConversation =
          conversationData.prepareConversationWithAttachmentInResponse(
            dalleImageUrl,
            ModelIds.DALLE,
          );
        conversationData.resetData();
        gptProVisionConversation =
          conversationData.prepareConversationWithAttachmentInRequest(
            gptProVisionImageUrl,
            ModelIds.GPT_4_VISION_PREVIEW,
            true,
          );
        conversationData.resetData();
        historyConversation = conversationData.prepareHistoryConversation(
          dalleConversation,
          gptProVisionConversation,
        );
        await dataInjector.createConversations([historyConversation]);
        await localStorageManager.setSelectedConversation(historyConversation);
        conversationPath = `${API.importFilePath(BucketUtil.getBucket())}/${historyConversation.name}`;
      },
    );

    await dialTest.step(
      'Start exporting conversation with attachments with two models and cancel in the middle',
      async () => {
        await dialHomePage.openHomePage();
        await dialHomePage.waitForPageLoaded();
        await conversations.openConversationDropdownMenu(
          historyConversation.name,
        );
        await conversationDropdownMenu.selectMenuOption(MenuOptions.export);
        await conversationDropdownMenu.selectMenuOption(
          MenuOptions.withAttachments,
        );
        await importExportLoader.waitForState({ state: 'attached' });
        await importExportLoader.stopLoading.click();
        await importExportLoader.waitForState({ state: 'hidden' });
        const exportedFiles = FileUtil.getExportedFiles();
        expect
          .soft(
            exportedFiles?.find((f) =>
              f.includes(Import.importAttachmentExtension),
            ),
            ExpectedMessages.dataIsNotExported,
          )
          .toBeUndefined();
      },
    );

    await dialTest.step(
      'Export conversation with attachments with two models',
      async () => {
        await conversations.openConversationDropdownMenu(
          historyConversation.name,
        );
        await conversationDropdownMenu.selectMenuOption(MenuOptions.export);
        exportedData = await dialHomePage.downloadData(() =>
          conversationDropdownMenu.selectMenuOption(
            MenuOptions.withAttachments,
          ),
        );

        const exportedFiles = FileUtil.getExportedFiles();
        expect
          .soft(
            exportedFiles?.find((f) =>
              f.includes(Import.importAttachmentExtension),
            ),
            ExpectedMessages.dataIsExported,
          )
          .toBeDefined();
      },
    );

    await dialTest.step(
      'Delete conversation, re-import exported file and stop import in the middle',
      async () => {
        await chatBar.deleteAllEntities();
        await confirmationDialog.confirm({ triggeredHttpMethod: 'DELETE' });
        await dialHomePage.uploadData(exportedData, () =>
          chatBar.importButton.click(),
        );
        await importExportLoader.waitForState({ state: 'attached' });
        await importExportLoader.stopLoading.click();
        await importExportLoader.waitForState({ state: 'hidden' });
        const isConversationImported = await conversations
          .getConversationByName(historyConversation.name)
          .isVisible();
        expect
          .soft(isConversationImported, ExpectedMessages.dataIsNotImported)
          .toBeFalsy();
      },
    );

    await dialTest.step(
      'Re-import exported file and verify conversation is exported',
      async () => {
        await dialHomePage.importFile(exportedData, () =>
          chatBar.importButton.click(),
        );
        await conversations
          .getConversationByName(historyConversation.name)
          .waitFor();
        const messagesCount =
          await chatMessages.chatMessages.getElementsCount();
        expect
          .soft(messagesCount, ExpectedMessages.messageCountIsCorrect)
          .toBe(historyConversation.messages.length);
      },
    );

    await dialTest.step(
      'Open attachment from response and verify image is loaded, attachment url is pointing to import path',
      async () => {
        dalleAttachmentPath = `${conversationPath}/${Attachment.sunImageName}`;
        await chatMessages.openChatMessageAttachment(
          2,
          Attachment.sunImageName,
        );
        const dalleActualAttachmentUrl =
          await chatMessages.getChatMessageAttachmentUrl(2);
        const dalleActualDownloadUrl =
          await chatMessages.getChatMessageDownloadUrl(2);
        expect
          .soft(dalleActualAttachmentUrl, ExpectedMessages.attachmentUrlIsValid)
          .toContain(dalleAttachmentPath);
        expect
          .soft(dalleActualDownloadUrl, ExpectedMessages.attachmentUrlIsValid)
          .toContain(dalleAttachmentPath);
      },
    );

    //TODO: uncomment when https://github.com/epam/ai-dial-chat/issues/819 is fixed
    // await dialTest.step(
    //   'Download attachment from request and verify attachment url is pointing to import path',
    //   async () => {
    //     gptProVisionAttachmentPath = `${conversationPath}/${Attachment.heartImageName}`;
    //     const gptProVisionActualDownloadUrl =
    //       await chatMessages.getChatMessageDownloadUrl(3);
    //     expect
    //       .soft(
    //         gptProVisionActualDownloadUrl,
    //         ExpectedMessages.attachmentUrlIsValid,
    //       )
    //       .toContain(gptProVisionAttachmentPath);
    //   },
    // );
  },
);
